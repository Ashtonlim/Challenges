import "pe"

rule Q1
{
	meta:
		description = "pe module is used to allow accessing of Portable Executable (PE) files section names as well as the number of sections exist in that file. FOR loop is used to iterate all the sections available and check if the file's section names suggest it is related to UPX."

	strings:
		$MZ_header = "MZ"
		$UPX_signature = "UPX!"

	condition:
		// QUESTION 1 PART A
		// check if "MZ" is in the first two bytes of the file
		$MZ_header in (0..1)
		and
		// QUESTION 1 PART B
		// interact all the sections available to check their names
		for any i in (0..pe.number_of_sections - 1) : (pe.sections[i].name contains "UPX")
		and 
		// QUESTION 1 PART C
		// look for the UPX signature in the file
		$UPX_signature

}

rule Q2
{
	strings:
		// QUESTION 2 PART A
		$subject = /Subject: [\S\s]*[Rr]esume/
		// QUESTION 2 PART B
		$filename = "my_resume.zip"
		$filename_base64 = "bXlfcmVzdW1lLnppcA=="
		// QUESTION 2 PART C
		$introduction = "my name is"
		$introduction_base64 = "bXkgbmFtZSBpc"

	condition:
		$subject and ($filename or $filename_base64) and ($introduction or $introduction_base64)
}

rule Q3
{
	strings:
		$LocalFile_header = {50 4B 03 04}
		$EOCD_header = {50 4B 05 06}
		$spanned_header = {50 4B 07 08}
		$exe_extension = ".exe"
		$dll_extension = ".dll"
		$scr_extension = ".scr"

	condition:
		// QUESTION 3 PART A
		// check for ZIP file header using End of central directory record incase ZIP file is empty
		$EOCD_header in (0..3)
		or
		// check for ZIP file header using Spanned File Header
		$spanned_header in (0..3)
		or
		// check for ZIP file header using Local File Header
		($LocalFile_header in (0..3)
		and
		// QUESTIOKN 3 PART B
		// check only the extension of the file by looking at the last 4 characters. Avoid situation such as "test.exe.txt"
		for all i in (1..#LocalFile_header) : ($exe_extension in (@LocalFile_header[i]+26+uint16(@LocalFile_header[i]+26)..@LocalFile_header[i]+30+uint16(@LocalFile_header[i]+26)) or
			$dll_extension in (@LocalFile_header[i]+26+uint16(@LocalFile_header[i]+26)..@LocalFile_header[i]+30+uint16(@LocalFile_header[i]+26)) or
			$scr_extension in (@LocalFile_header[i]+26+uint16(@LocalFile_header[i]+26)..@LocalFile_header[i]+30+uint16(@LocalFile_header[i]+26)))
		)
}


rule Q4
{
	meta:
		description_partA1 = "Between the two samples, MOV operation from local variable on the stack is to different size of the register. Therefore, we needed 8A or 8B to satisfy both samples. For the operands, I added wild cases assuming the mnemonic does not change while the operands do."
		description_partA2 = "Between the two samples, increment of the global variable is at the same location. Therefore, we can use the same immediate value for the location. For encoding or decoding, 3F is being used in both samples."
		description_partB = "As the operand sizes varies, the opcode varies. For PUSH operation, I took into the account of pushing up to 4 bytes of immediate value. Therefore, the range is from 1 to 4. For ADD or SUB operation, opcode 00 and 02 for ADD for example will achieve the same result."

	strings:
		// QUESTION 4 PART A1
		$codeStructure_partA1 = {(8A | 8B) ?? ?? 8A ?? ?? FF 05 ?? ?? ?? ?? 2A ?? 80 ?? ?? 02 ?? 6A ?? 88 ??}
		// QUESTION 4 PART A2
		$codeStructure_partA2 = {(8A | 8B) ?? ?? 8A ?? ?? FF 05 00 30 00 10 2A ?? 80 ?? 3F 02 ?? 6A ?? 88 ??}
		// QUESTION 4 PART B
		$codeStructure_partB = {(8A | 8B) [2] 8A [2] FF 05 00 30 00 10 (28 | 2A) ?? 80 ?? 3F (00 | 02) ?? (6A | 68) [1-4] 88 ??}

	condition:
		all of them
}
